// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../pixi.js
//   ../../../@tweenjs/tween.js

declare module 'UAENGINE' {
    import World from 'UAENGINE/Core/Engine/World';
    import Entity from 'UAENGINE/Core/Engine/Entity';
    import Loop from 'UAENGINE/Core/Engine/Loop';
    import Loader from 'UAENGINE/Core/Engine/Loader';
    import Events from 'UAENGINE/Core/Engine/Events';
    import LevelManager from 'UAENGINE/Core/Engine/LevelManager';
    import Game from 'UAENGINE/Core/Game';
    import GameConfig from 'UAENGINE/Core/Engine/GameConfig';
    import GOFactory from 'UAENGINE/Core/Engine/GOFactory';
    import Geom from 'UAENGINE/Core/Geom/Geom';
    /**
      * @class the UAEngine API.
      */
    class UAENGINE {
        static world: World;
        static entity: Entity;
        static loop: Loop;
        static loader: Loader;
        static events: Events;
        static levelManager: LevelManager;
        static game: Game;
        static goFactory: GOFactory;
        static gameConfig: GameConfig;
        static geom: Geom;
    }
    export default UAENGINE;
}

declare module 'UAENGINE/Core/Engine/World' {
    import Entity from 'UAENGINE/Core/Engine/Entity';
    import IScreen from 'UAENGINE/Services/IScreen';
    import ILevel from 'UAENGINE/Core/Engine/ILevel';
    import Events from 'UAENGINE/Core/Engine/Events';
    class World {
            _screen: IScreen;
            constructor(entity: Entity, screen: IScreen, events: Events);
            /**
                * @description initialize the game world. This generates an empty screen
                * @param w The width value to initialize the world with. Defines the width of the game screen.
                * @param h The height value to initialze the world with. Defintes the height of the game screen.
                */
            init(w: number, h: number): void;
            /**
                * @description launches the specified level. Will automatically shutdown the currentLevel, if there is one.
                * @param level the level object to launch.
                */
            startLevel(level: ILevel, scriptName: string): void;
            /**
                * @description resize the game screen
                * @param width the new width of the game screen
                * @param height the new height of the game screen
                */
            resize(width: number, height: number): void;
            debugScreen(): void;
            width(): number;
            height(): number;
    }
    export default World;
}

declare module 'UAENGINE/Core/Engine/Entity' {
    import AnimationManager from 'UAENGINE/Core/Engine/AnimationManager';
    import Events from 'UAENGINE/Core/Engine/Events';
    import ScaleManager from 'UAENGINE/Core/Engine/ScaleManager';
    import IScreen from 'UAENGINE/Services/IScreen';
    import IObjectHandler from 'UAENGINE/Services/IObjectHandler';
    import InputHandler from 'UAENGINE/Core/Engine/InputHandler';
    import MathUtils from 'UAENGINE/Core/Engine/Utils/MathUtils';
    import Point from 'UAENGINE/Core/Geom/Point';
    class Entity {
        _animationManager: AnimationManager;
        _objectHandler: IObjectHandler;
        _math: MathUtils;
        _scaleManager: ScaleManager;
        protected _pointFactory: Point;
        constructor(screen: IScreen, animationManager: AnimationManager, objectHandler: IObjectHandler, input: InputHandler, math: MathUtils, events: Events, scaleManager: ScaleManager, pointFactory: Point);
        set text(lett: string);
        set x(xVal: number);
        set y(yVal: number);
        set width(width: number);
        get width(): number;
        get height(): number;
        set origin(origin: Point);
        get origin(): Point;
        set height(height: number);
        setSize(width: number, height: number): void;
        set scaleX(xVal: number);
        set scaleY(yVal: number);
        get x(): number;
        get y(): number;
        get input(): InputHandler;
        get scaleX(): number;
        get scaleY(): number;
        get text(): string;
        get pixelPerfect(): boolean;
        setStyle(style: any): void;
        setTextColor(color: string): void;
        destroy(): void;
        makePixelPerfect(threshold?: number): boolean;
        get children(): Entity[];
        get parent(): Entity | null;
        set parent(parent: Entity | null);
        get data(): any;
        addChild(entity: Entity): boolean;
        removeChild(entity: Entity): boolean;
        hasChild(entity: Entity): boolean;
        relativeMove(xDiff: number, yDiff: number): void;
        initSpine(x: number, y: number, spine: string): void;
        moveBy(x: number, y: number): void;
        moveTo(x: number, y: number): void;
        setOrigin(x: number, y?: number): void;
        initNineSlice(x: number, y: number, textureName: string, leftWidth?: number, topHeight?: number, rightWidth?: number, bottomHeight?: number): void;
        init(x: number, y: number, sprite: string, frame?: string | null): void;
        initContainer(x: number, y: number): void;
        initText(x: number, y: number, text: string, style?: any): void;
        addTween(name: string, easing: string): void;
        playTween(name: string, toObject: any, time: number, updateFunction?: Function): void;
        pauseTween(name: string): void;
        resumeTween(name: string): void;
        pauseAnimation(name: string): void;
        resumeAnimation(name: string): void;
        addAnimation(name: string, base: string, max: number, fps: number, data: any): void;
        addSpineAnimation(name: string, fps: number): void;
        playAnimation(name: string): void;
        playSpineAnimation(name: string): void;
        enableInput(): void;
        disableInput(): void;
        addInputListener(event: string, callback: Function, context: any, once?: boolean): void;
        removeInputListener(event: string, callback: Function): void;
        createNew(): Entity;
        changeTexture(textureName: string): void;
        update(time: number): void;
    }
    export default Entity;
}

declare module 'UAENGINE/Core/Engine/Loop' {
    import Events from 'UAENGINE/Core/Engine/Events';
    import FunObj from 'UAENGINE/Core/Data/FunObj';
    class Loop {
            constructor(events: Events, funObj: FunObj);
            /**
                * @description add a function to the list of callbacks for this loop
                * @param f the function to add to the list of callbacks
                * @param context the context
                */
            addFunction(f: any, context: any): void;
            /**
                * @description remove a callback from this loop
                * @param f the function to remove from callbacks array
                */
            removeFunction(f: any): void;
            /**
                * @description start the loop -- interally, this binds the loop to requestAnimatonFrame on window obj.
                */
            start(): void;
    }
    export default Loop;
}

declare module 'UAENGINE/Core/Engine/Loader' {
    import Resource from 'UAENGINE/Core/Data/Resource';
    import IImgLoader from 'UAENGINE/Services/IImgLoader';
    import ISndLoader from 'UAENGINE/Services/ISndLoader';
    import AjaxLoader from 'UAENGINE/Services/AjaxLoader';
    import GameConfig from 'UAENGINE/Core/Engine/GameConfig';
    class Loader {
            _sndLoader: ISndLoader;
            _ajaxLoader: AjaxLoader;
            /**
                * @description the base path to load assets from.
                */
            get base(): string;
            set base(base: string);
            get scripts(): any;
            constructor(resource: Resource, imgLoader: IImgLoader, sndLoader: ISndLoader, ajaxLoader: AjaxLoader, gameConfig: GameConfig);
            get downloadComplete(): boolean;
            /**
                * @description Creates an image resource and adds the image to the load queue. The data property of the resource will be
                * populated with the image once loaded; Everything in the queue is processed when the download() method is called
                * @param name the filename of the image to load. This is added to the base path value to find the image file.
                */
            addImage(name: string): void;
            /**
                * @description Creates an atlas resource and adds adds the atlas to the load queue. The data property of the resource will be
                * populated with the image once loaded; Everything in the queue is processed when the download() method is called
                * @param filename the filename of the atlas you wish to load
                */
            addAtlas(filename: string): void;
            addJSON(basename: string): void;
            addSpine(name: string, jsonUrl: string): void;
            /**
                * @description download everything in the load queue. This must be done before the activity can start.
                * @param onDone (optional) called when loading is complete
                */
            download(onDone?: Function): Promise<unknown>;
            getResource(name: string): Resource | null;
            getTexture(sprite: string, frame?: string | null): any;
            update(): void;
            getSndResByBasename(basename: string): Resource | null;
            /**
                * @description create a sound resource, to be inject with data later, at download
                * @param filename the filename of the sound to be loaded, without extension.
                */
            addSnd(name: string): void;
            /**
             * @description create several sound resources, to be injected with data (howls) at download phase
             * @param filenames filenames array of the sounds to be loaded, without extension (extentions are defined in config file).
             */
            addSnds(filenames: string[]): void;
            loadActScript(file: string, callback?: Function, staticPath?: boolean): any;
    }
    export default Loader;
}

declare module 'UAENGINE/Core/Engine/Events' {
    class Events {
            constructor();
            get events(): any;
            /**
                * @description returns an array of all timers
                */
            get timers(): any;
            /**
                * @description is the timer system paused?
                */
            get paused(): boolean;
            /**
                * @description returns a string array of the names of all registered events
                */
            eventNames(): string[];
            /**
                *
                * @param event adds an event to the array of registered events
                */
            addEvent(event: string): void;
            /**
                *
                * @param event remove an event from the array of registered events
                */
            removeEvent(event: string): void;
            /**
                * @description add a listener to an event.
                * @param event name of the event. If it doesn't exist, it will be created.
                * @param callback the callback function to fire when the event emits.
                * @param context the context for the callback
                */
            addListener(event: string, callback: Function, context: any): void;
            /**
                * @description remove a listener (callback) from an event
                * @param event the event
                * @param callback the callback to remove
                */
            removeListener(event: string, callback: Function): void;
            /**
                * @description add a listener to an event.
                * @param event name of the event. If it doesn't exist, it will be created.
                * @param callback the callback function to fire when the event emits.
                * @param context the context for the callback
                */
            on(event: string, callback: Function, context: any): void;
            /**
             * @description add a listener to an event, to be called only one time, then removed from the list of callbacks.
             * @param event name of the event. If it doesn't exist, it will be created.
             * @param callback the callback function to fire when the event emits.
             * @param context the context for the callback
             */
            once(event: string, callback: Function, context: any): void;
            /**
             * @description remove a listener (callback) from an event
             * @param event the event
             * @param callback the callback to remove
             */
            off(event: string, callback: Function): void;
            /**
                * @description emit an event
                * @param event the event to emit
                * @param data (optional) data object to pass to the callbacks for the event
                */
            fire(event: string, data?: any): void;
            /**
             * @description emit an event
             * @param event the event to emit
             * @param data (optional) data object to pass to the callbacks for the event
             */
            emit(event: string, data?: any): void;
            /**
             * @description emit an event
             * @param event the event to emit
             * @param data (optional) data object to pass to the callbacks for the event
             */
            trigger(event: string, data?: any): void;
            /**
                * @description creates a timed callback, which is pausable via events.pause and events.resume. Optional repeat is 0 by default,
                * meaning method executes once. Setting this to -1 will repeat continuosly.
                * @param callback the function to call after the delay has elapsed.
                * @param delay the amound of (unpaused) milliseconds to wait before execution.
                * @param context the context to call it in
                * @param repeat should repeat? 0 for no. -1 for infinity, 3 for 3 repeats, 4 for 4 etc...
                */
            timer(callback: Function, delay: number, context: any, repeat?: number): any;
            /**
                * @description find and remove a timer object based via the callback it contains
                * @param callback the callback of the timer object to be removed
                */
            removeTimer(callback: Function): void;
            clearTimers(): void;
            /**
                * @description find the timer object from the _timers array which contains the specified callback mathod
                * @param callback the callback of the timer object to be retrieved
                */
            getTimer(callback: Function): any;
            /**
                * @description suspends the ticker for all timer objects
                */
            pause(): void;
            /**
                * @description resumes the ticker for all timer objects
                */
            resume(): void;
    }
    export default Events;
}

declare module 'UAENGINE/Core/Engine/LevelManager' {
    import AudioManager from "UAENGINE/Core/Engine/AudioManager";
    import Events from "UAENGINE/Core/Engine/Events";
    import Utils from "UAENGINE/Core/Engine/Utils/Utils";
    import ScriptHandler from "UAENGINE/Core/Engine/ScriptHandler";
    import InputHandler from 'UAENGINE/Core/Engine/InputHandler';
    import GOFactory from "UAENGINE/Core/Engine/GOFactory";
    class LevelManager {
        constructor(audioManager: AudioManager, events: Events, script: ScriptHandler, utils: Utils, input: InputHandler, goFactory: GOFactory);
        /**
          * @description initialize the level manager.
          * @param scriptName the name of the script to initialize the script handler with
          * @param scriptRaw the raw script data for the script handler
          * @param parseCols the names of the columns to be parsed into arrays of names (i.e 'horse,dog,cat' => [horse, dog, cat])
          * @param objectifyCols the names of the columns to be converted into objects with key-value pairs. For example:
          * 'bgd: bgd_1\noverlay: overlay_1'
          * => {bgd: 'bgd_1', overlay: 'overlay_1'}
          * @param processText (optional) the column names to convert into lines and words of text. Mainly useful in passage (reading) types.
          */
        init(scriptName: string, scriptRaw: any[], parseCols: string[], objectifyCols: string[], processText?: string[]): void;
        get events(): Events;
        get audio(): AudioManager;
        get script(): ScriptHandler;
        get utils(): Utils;
        get input(): InputHandler;
        get goFactory(): GOFactory;
    }
    export default LevelManager;
}

declare module 'UAENGINE/Core/Game' {
    import World from 'UAENGINE/Core/Engine/World';
    import Events from 'UAENGINE/Core/Engine/Events';
    import ScaleManager from 'UAENGINE/Core/Engine/ScaleManager';
    import Expose from 'UAENGINE/Core/Engine/Expose';
    import Entity from 'UAENGINE/Core/Engine/Entity';
    import Loop from 'UAENGINE/Core/Engine/Loop';
    import Loader from 'UAENGINE/Core/Engine/Loader';
    import GameConfig from 'UAENGINE/Core/Engine/GameConfig';
    import LevelManager from 'UAENGINE/Core/Engine/LevelManager';
    import ILevel from 'UAENGINE/Core/Engine/ILevel';
    import IActivity from 'UAENGINE/Core/Engine/IActivity';
    import GOFactory from 'UAENGINE/Core/Engine/GOFactory';
    import Geom from 'UAENGINE/Core/Geom/Geom';
    class Game {
            _events: Events;
            _expose: Expose;
            _loop: Loop;
            _loader: Loader;
            _gameConfig: GameConfig;
            _levelManager: LevelManager;
            _geom: Geom;
            constructor(world: World, entity: Entity, loop: Loop, loader: Loader, events: Events, scaleManager: ScaleManager, expose: Expose, gameConfig: GameConfig, levelManager: LevelManager, goFactory: GOFactory, geom: Geom);
            /**
                * @description adds an activity to the engine, as a plugin (todo)
                * @param act the act object to add.
                */
            addActivity(act: IActivity): void;
            /**
                * @description say hi!
                */
            sayHi(): void;
            /**
                * @description start the game. Calls game.init internally, to create the game screen.
                * @param configPath the path to the config.json file, which specified Display widht, height, file paths etc
                */
            startGame(configPath: string): Promise<unknown>;
            /**
                * @description load a level (via world.loadLevel).
                * @param level the level to load
                */
            loadLevel(level: ILevel, scriptName: string): void;
    }
    export default Game;
}

declare module 'UAENGINE/Core/Engine/GameConfig' {
    class GameConfig {
        constructor();
        get data(): any;
        /**
          * @desecription load a config.json file from the specified path
          * @param path the path to load the config json data from
          */
        loadConfig(path: string): Promise<unknown>;
    }
    export default GameConfig;
}

declare module 'UAENGINE/Core/Engine/GOFactory' {
    import Entity from "UAENGINE/Core/Engine/Entity";
    class GOFactory {
            constructor(entity: Entity);
            /**
                * @description creates and returns a text object
                * @param x the x coordinate to initialize with
                * @param y the y coordinate to initialize with
                * @param text the text value to initialize with
                * @param style a css style object to apply to the text
                */
            text(x: number, y: number, text: string, style: any): Entity;
            /**
                * @description returns a Sprite object
                * @param x the x coordinate to initialize with
                * @param y the y coordinate to initialize with
                * @param textureName the name of the texture to initialize the sprite with
                * @param frame the default frame for the Sprite. Optional. Provide this if working with an atlas animation
                */
            sprite(x: number, y: number, textureName: string, frame?: string | null): Entity;
            /**
                *
                * @param x the x coordinate to initialze with
                * @param y the y coordinate to initialize with
                * @param textureName the name of the loaded texture to initiaze the object with
                * @param leftWidth The number of pixels to come in on the left before you reach the mid section of the slice. This part will never stretch
                * @param topHeight The number of pixels to come in from the top before you reach the repeating section of the slice. This part will never stretch
                * @param rightWidth The number of pixels to come in from the right before you reach the repeating section of the slice. This part will never stretch
                * @param bottomHeight The number of pixels to come in from the bottom before you reach the repeating section of the slice. This part will never stretch
                */
            nineSlice(x: number, y: number, textureName: string, leftWidth?: number, topHeight?: number, rightWidth?: number, bottomHeight?: number): Entity;
            /**
                * @description creates and returns an empty 'container', analogous to PIXI.Container
                * @param x the x coordinate to initialize with
                * @param y the y coordinate to initialize with
                */
            container(x: number, y: number): Entity;
            /**
                * @description creates and returns a Spine object
                * @param x the x coordinate to initialize with
                * @param y the y coordinate to initialize with
                * @param spineName the name of the spine file to initialize with
                */
            spine(x: number, y: number, spineName: string): Entity;
    }
    export default GOFactory;
}

declare module 'UAENGINE/Core/Geom/Geom' {
    import Circle from "UAENGINE/Core/Geom/Circle";
    import Point from "UAENGINE/Core/Geom/Point";
    import LineSegment from 'UAENGINE/Core/Geom/LineSegment';
    import Rect from "UAENGINE/Core/Geom/Rect";
    import Polygon from 'UAENGINE/Core/Geom/Polygon';
    class Geom {
        protected _circle: Circle;
        protected _lineSegment: LineSegment;
        protected _point: Point;
        protected _rect: Rect;
        protected _polygon: Polygon;
        constructor(circle: Circle, lineSegment: LineSegment, point: Point, rect: Rect, polygon: Polygon);
        circle(x: number, y: number, r: number): Circle;
        lineSegment(pnt1: Point, pnt2: Point): LineSegment;
        point(x: number, y: number): Point;
        rect(x: number, y: number, width: number, height: number): Rect;
        polygon(center: Point, points: Point[]): Polygon;
    }
    export default Geom;
}

declare module 'UAENGINE/Services/IScreen' {
    import { Sprite } from 'pixi.js';
    interface IScreen {
        addHitMap(object: Sprite, threshold: number): void;
        createScreen(width: number, height: number, elementId: string): void;
        createContainer(x: number, y: number): any;
        createText(x: number, y: number, text: string, style?: any): any;
        createSprite(x: number, y: number, name: string, frame: string | null): any;
        createNineSlice(x: number, y: number, name: string, leftWidth?: number, topHeight?: number, rightWidth?: number, bottomHeight?: number): any;
        clearScreen(): void;
        changeTexture(sprite: Sprite, name: string, frame?: string | null): void;
        createSpine(name: string): any;
        enableInput(sprite: any): void;
        disableInput(sprite: any): void;
        addListener(event: string, sprite: any, callback: Function, context: any): void;
        removeListener(event: string, sprite: any, callback: Function): void;
        resize(width: number, height: number): void;
        debugScreen(): void;
        width(): number | null;
        height(): number | null;
    }
    export default IScreen;
}

declare module 'UAENGINE/Core/Engine/ILevel' {
    interface ILevel {
        init(scriptName: string): void;
        start(): void;
        shutdown(): void;
    }
    export default ILevel;
}

declare module 'UAENGINE/Core/Engine/AnimationManager' {
    import Anim from 'UAENGINE/Core/Data/Anim';
    import Tween from 'UAENGINE/Core/Data/Tween';
    class AnimationManager {
        _activeAnimation: Anim | null;
        _tween: Tween;
        constructor(anim: Anim, tween: Tween);
        play(name: string): void;
        playSpine(name: string): void;
        pause(name: string): void;
        resume(name: string): void;
        addTween(name: string, easing: string, object: any): void;
        playTween(name: string, toObject: any, time: number, updateFunction?: Function): void;
        pauseTween(name: string): void;
        resumeTween(name: string): void;
        addSpineAnimation(name: string, fps: number, data: any): void;
        addAnimation(name: string, base: string, max: number, fps: number, data: any): void;
        createNew(): AnimationManager;
        getUpdatedFrame(): string | null;
        update(time: number): void;
    }
    export default AnimationManager;
}

declare module 'UAENGINE/Core/Engine/ScaleManager' {
    import GameConfig from 'UAENGINE/Core/Engine/GameConfig';
    class ScaleManager {
        constructor(gameConfig: GameConfig);
        init(): void;
        getXY(x: number, y: number): {
            x: number;
            y: number;
        };
        getScale(currentScale: number): number;
        createNew(): ScaleManager;
    }
    export default ScaleManager;
}

declare module 'UAENGINE/Services/IObjectHandler' {
    import Point from 'UAENGINE/Core/Geom/Point';
    interface IObjectHandler {
        setXy(object: any, x: number, y: number): void;
        setSize(object: any, width: number, height: number): void;
        setPivot(object: any, anchor: Point): void;
        setX(object: any, x: number): void;
        setY(object: any, y: number): void;
        setScaleXY(object: any, x: number, y: number): void;
        setStyle(text: any, style: any): void;
        setTextColor(text: any, color: string): void;
        destroy(object: any): void;
    }
    export default IObjectHandler;
}

declare module 'UAENGINE/Core/Engine/InputHandler' {
    import Events from "UAENGINE/Core/Engine/Events";
    import Loader from "UAENGINE/Core/Engine/Loader";
    import Point from "UAENGINE/Core/Geom/Point";
    import IScreen from "UAENGINE/Services/IScreen";
    import EventNames from "UAENGINE/Core/Engine/EventNames";
    class InputHandler {
            protected _pointFactory: Point;
            constructor(events: Events, loader: Loader, screen: IScreen, eventNames: EventNames, pointFactory: Point);
            /**
                * @description get the pointer position as a Point object (x, y)
                */
            get pointer(): Point;
            /**
                * @description enable input for the specified object
                * @param displayObject the object to enable input for
                */
            enable(displayObject: any): void;
            /**
                * @description disable input for the specified object
                * @param displayObject the object to disable input for
                */
            disable(displayObject: any): void;
            /**
                * @description add listener for specified input event to specific sprite
                * @param event the event to add the listener to; must be a valid input event
                * @param callback the callback method to register
                * @param sprite the sprite this event lisener is being associated with
                * @param context the context of the callback
                */
            addListener(event: string, callback: Function, sprite: any, context: any): void;
            /**
                * @description remove listener from input event
                * @param event
                *
                * @param callback
                * @param sprite
                */
            removeListener(event: string, callback: Function, sprite: any): void;
    }
    export default InputHandler;
}

declare module 'UAENGINE/Core/Engine/Utils/MathUtils' {
    class MathUtils {
            /**
                * @description get a range of numbers in an array, from lowest to highest
                * @param lowest the number to start the range on
                * @param finish the number to finish the range on
                */
            static getRangeArray(lowest: number, highest: number): number[];
            /**
                * @description get the smallest number in an array
                * @param a the array of numbers to be assessed
                */
            static getSmallestNumber(a: Number[]): number;
            clamp(val: number, min: number, max: number): number;
            round(val: number): number;
    }
    export default MathUtils;
}

declare module 'UAENGINE/Core/Geom/Point' {
    class Point {
        protected _x: number;
        protected _y: number;
        constructor();
        init(x: number, y: number): void;
        get x(): number;
        set x(x: number);
        get y(): number;
        set y(y: number);
        createNew(x: number, y: number): Point;
    }
    export default Point;
}

declare module 'UAENGINE/Core/Data/FunObj' {
    class FunObj {
        constructor();
        get function(): any;
        init(f: any, context: any): void;
        execute(data: any): any;
        createNew(): FunObj;
    }
    export default FunObj;
}

declare module 'UAENGINE/Core/Data/Resource' {
    class Resource {
            constructor();
            get data(): any;
            get name(): string;
            /**
                * @description returns the basename of the file, without file extension
                */
            get basename(): string;
            get url(): string;
            get loaded(): boolean;
            set data(dat: any);
            set loaded(ld: boolean);
            initImage(url: string, loaded: boolean): void;
            initSnd(url: string, loaded: boolean): void;
            initJSON(url: string, loaded: boolean): void;
            isImg(): boolean;
            isSnd(): boolean;
            createNew(): Resource;
    }
    export default Resource;
}

declare module 'UAENGINE/Services/IImgLoader' {
    interface IImgLoader {
        loadImages(images: string[], onProgress: any, onDone: any, context: any): void;
        loadSpine(name: string, jsonUrl: string): void;
        getResources(foo: Function): void;
        getTexture(resource: any, frame: any): any;
        download(onDone?: Function): void;
    }
    export default IImgLoader;
}

declare module 'UAENGINE/Services/ISndLoader' {
    interface ISndLoader {
        loadSounds(urls: string[], extensions: string[], onProgress: Function, onComplete: Function, context: any): void;
        baseURL: string;
    }
    export default ISndLoader;
}

declare module 'UAENGINE/Services/AjaxLoader' {
    class AjaxLoader {
        constructor();
        loadFile(url: string, onDone?: Function): void;
    }
    export default AjaxLoader;
}

declare module 'UAENGINE/Core/Engine/AudioManager' {
    import Loader from 'UAENGINE/Core/Engine/Loader';
    import HwPlayer from 'UAENGINE/Services/Howler/HwPlayer';
    class AudioManager {
            _hwPlayer: HwPlayer;
            constructor(loader: Loader, hwLoader: HwPlayer);
            get filesPlaying(): string[];
            /**
                * @description play the specified audio file
                * @param name the name of the file to play
                * @param onStop called when the file has stopped playing
                * @param loop should the file loop?
                */
            play(name: string, onStop: Function, loop?: boolean): void;
            /**
                * @description for playing instructional audio arrays, one after the other. Mostly used for playing contents of audio_id in scripts
                * @param arr the array of audio ids to play
                * @param onDone Called when the entire array has been played.
                */
            playInstructionArr(arr: string[], onDone: Function): void;
            /**
                * @description Specifically for playing music, since there can only be one music file playing at a time.
                * @param name the name of the music file to play
                * @param onStop called when the file has stopped playing
                * @param loop should the file loop?
                */
            playMusic(name: string, onStop: Function, loop?: boolean): void;
            /**
                * @description stop music playback
                */
            stopMusic(): void;
            /**
                * @description stop playback for specified file
                * @param name the name of the file to stop playback for
                */
            stop(name: string): void;
    }
    export default AudioManager;
}

declare module 'UAENGINE/Core/Engine/Utils/Utils' {
    import ActScripts from 'UAENGINE/Core/Engine/Utils/ActScripts';
    import Collections from 'UAENGINE/Core/Engine/Utils/Collections';
    import Mixins from 'UAENGINE/Core/Engine/Utils/Mixins';
    import Colors from 'UAENGINE/Core/Engine/Utils/Colors';
    import MathUtils from 'UAENGINE/Core/Engine/Utils/MathUtils';
    import Text from 'UAENGINE/Core/Engine/Utils/Text';
    import Vectors from 'UAENGINE/Core/Engine/Utils/Vectors';
    class Utils {
        constructor(actScripts: ActScripts, collections: Collections, colors: Colors, mixins: Mixins, math: MathUtils, text: Text, vectors: Vectors);
        get script(): ActScripts;
        get coll(): Collections;
        get color(): ActScripts;
        get mixin(): Mixins;
        get math(): MathUtils;
        get text(): Text;
        get vector(): Vectors;
    }
    export default Utils;
}

declare module 'UAENGINE/Core/Engine/ScriptHandler' {
    import ActScripts from 'UAENGINE/Core/Engine/Utils/ActScripts';
    import Events from 'UAENGINE/Core/Engine/Events';
    class ScriptHandler {
            constructor(utils: ActScripts, events: Events);
            /**
                 * @description initialize the level manager.
                 * @param scriptName the name of the script to initialize the script handler with
                 * @param scriptRaw the raw script data for the script handler
                 * @param parseCols the names of the columns to be parsed into arrays of names (i.e 'horse,dog,cat' => [horse, dog, cat])
                 * @param objectifyCols the names of the columns to be converted into objects with key-value pairs. For example:
                 * 'bgd: bgd_1\noverlay: overlay_1'
                 * => {bgd: 'bgd_1', overlay: 'overlay_1'}
                 * @param processText (optional) the column names to convert into lines and _words of text. Mainly useful in passage (reading) types.
                 */
            init(name: string, raw: any[], parseCols: string[], objectifyCols: string[], processText?: string[]): void;
            get name(): string;
            get initialized(): boolean;
            get raw(): any[];
            get rows(): any[];
            /**
                * @description get the active row.
                */
            get active(): any;
            /**
                * @description set the active row.
                */
            set active(row: any);
            /**
                * @description get the last row (the previous value of active)
                */
            get last(): any;
            /**
                * @description switches the active row to the one specified
                * @param row the row object to switch to
                */
            goTo(row: any): void;
            /**
                * @description switches the active row to the one with the id the auto_next field points to
                */
            goToAutoNext(): void;
            /**
                * @description will return the row which the auto_next field for the current row points to. If falsy, logs warning.
                */
            getFromAutoNext(): any;
            /**
                * @description searches through all arrays in the specified columns, and returns every unique value. Duplicates
                * are removed.
                * @param cols the columns to search for files in i.e ['images', 'correct_image']; you may also specify a property within an 'object'
                * cell with dot syntax; i.e ['config.bgd'] will find all values of the bgd field for all pre-converted config cells.
                 *
                */
            fileList(cols: string[]): string[];
            /**
                * @description find the first row whose cells contain the specified vals
                * @param colname the columns (properties) to search for the respective vals in
                * @param val the vals to search for. The order of this array must match colname.
                */
            rowByCellVals(colname: string[], val: string[]): any[] | null;
            isFalsy(val: any): boolean;
    }
    export default ScriptHandler;
}

declare module 'UAENGINE/Core/Engine/Expose' {
    class Expose {
        constructor();
        init(): void;
        add(key: string, object: any): void;
    }
    export default Expose;
}

declare module 'UAENGINE/Core/Engine/IActivity' {
    interface IActivity {
        startActivity(scriptName: string): void;
    }
    export default IActivity;
}

declare module 'UAENGINE/Core/Geom/Circle' {
    import Point from "UAENGINE/Core/Geom/Point";
    class Circle {
        protected _pointFactory: Point;
        protected _center: Point;
        protected _radius: number;
        constructor(pointFactory: Point);
        init(x: number, y: number, r: number): void;
        set center(center: Point);
        get center(): Point;
        set radius(radius: number);
        get radius(): number;
        createNew(x: number, y: number, r: number): Circle;
    }
    export default Circle;
}

declare module 'UAENGINE/Core/Geom/LineSegment' {
    import Point from "UAENGINE/Core/Geom/Point";
    class LineSegment {
        protected _pointFactory: Point;
        constructor(pointFactory: Point);
        init(pnt1: Point, pnt2: Point): void;
        createNew(pnt1: Point, pnt2: Point): LineSegment;
    }
    export default LineSegment;
}

declare module 'UAENGINE/Core/Geom/Rect' {
    import Point from 'UAENGINE/Core/Geom/Point';
    class Rect {
        protected _pointFactory: Point;
        _x: number;
        _y: number;
        _width: number;
        _height: number;
        constructor(pointFactory: Point);
        init(x: number, y: number, width: number, height: number): void;
        get x(): number;
        get y(): number;
        set x(x: number);
        set y(y: number);
        get width(): number;
        set width(width: number);
        get height(): number;
        set height(height: number);
        halfHeight(): number;
        halfWidth(): number;
        topLeft(): Point;
        topCenter(): Point;
        center(): Point;
        topRight(): Point;
        rightCenter(): Point;
        bottomRight(): Point;
        bottomCenter(): Point;
        bottomLeft(): Point;
        leftCenter(): Point;
        createNew(x: number, y: number, width: number, height: number): Rect;
    }
    export default Rect;
}

declare module 'UAENGINE/Core/Geom/Polygon' {
    import Point from 'UAENGINE/Core/Geom/Point';
    class Polygon {
        protected _pointFactory: Point;
        constructor(pointFactory: Point);
        init(center: Point, points: Point[]): void;
        get center(): Point;
        set center(center: Point);
        setCenter(x: number, y: number): void;
        get points(): Point[];
        set points(points: Point[]);
        createNew(center: Point, points: Point[]): Polygon;
    }
    export default Polygon;
}

declare module 'UAENGINE/Core/Data/Anim' {
    import Events from 'UAENGINE/Core/Engine/Events';
    class Anim {
        constructor(events: Events);
        get name(): string;
        get data(): any;
        get frames(): string[];
        get fps(): number;
        init(name: string, base: string, max: number, fps: number, data: any): void;
        getNextFrame(): string;
        createNew(): Anim;
        startSpineAnimation(): void;
        pause(): void;
        resume(): void;
    }
    export default Anim;
}

declare module 'UAENGINE/Core/Data/Tween' {
    import * as TWEEN from '@tweenjs/tween.js';
    class Tween {
        _easing: string;
        _object: any;
        _data: TWEEN.Tween | null;
        _pausedTime: number;
        _time: number;
        _pauseDiff: number;
        constructor();
        get name(): string;
        init(name: string, easing: string, object: any): void;
        to(toObject: any, time: number, updateFunction?: Function): void;
        createNew(): Tween;
        update(time: number): void;
        pause(): void;
        resume(): void;
    }
    export default Tween;
}

declare module 'UAENGINE/Core/Engine/EventNames' {
    class EventNames {
        POINTER_DOWN: string;
        POINTER_UP: string;
    }
    export default EventNames;
}

declare module 'UAENGINE/Services/Howler/HwPlayer' {
    import Loader from 'UAENGINE/Core/Engine/Loader';
    import Resource from 'UAENGINE/Core/Data/Resource';
    class HwPlayer {
        constructor(loader: Loader);
        play(name: string, res: Resource, onStop: Function, loop?: boolean): void;
        pause(res: Resource): void;
        resume(res: Resource): void;
        stop(res: Resource): void;
    }
    export default HwPlayer;
}

declare module 'UAENGINE/Core/Engine/Utils/ActScripts' {
    class ActScripts {
            /**
            * @description a function to generate an array of objects from a column with 'stringified' tabular data. Use this for activity scripts with cells in columns which contain
            * more than one property, all baked into one string, with a : delineated, one line per property
            * @param array the array to pull the column from -- intended for object arrays generated from CSV files (tabular)
            * @param column the name of the column to generate objects from in the array
            */
            objectArrayifyColumn(array: any, column: string): any[];
            /**
                * @description break a string into seperate filenames, generally for image and sound references
                * @param text the string value from the 'cell', to be parsed.
                */
            getValsFromCell(text: string): string[];
            /**
                * @description returns all the unique values found in a column of the activity script, with comma delineated values
                * such as 'fish,dog,horse'
                * @param script the activityScript to pull the values from
                * @param column the name of the 'column' in the script, now a property belonging to all objects in the object array
                */
            getUniqValsFromCol(script: any, column: string): string[];
            /**
                * @description returns all the unique values found in comma delineated lists in all of the columns specified in
                * the cols array
                * @param script the script to pull the vals from
                * @param cols the 'columns', or properties, to include in the search
                */
            getUniqValsFromCols(script: any, cols: string[]): string[];
            /**
                * @description a simple helper method that takes an array, and returns it with all duplicate values removed
                * @param vals the array of values to remove duplicated from
                */
            getUniq(vals: string[]): string[];
            /**
                * @description generates an object with properties from a string, where each key-value pair is on a new line, colon assigns a value, and
                * comma seperates multiple values.
                * @param cellString the string that the cell was converted to from the Activity Script
                */
            objectifyCell(cellString: string): object;
            /**
                * @description returns the first row to match the specified criteria, or null if none
                * @param colnames the column names to look for values in. Order must match vals array
                * @param vals the vals to search for in the colnames array. Order must match colnames array.
                */
            rowByColsWithVals(rows: any[], colnames: string[], vals: string[]): any;
            /**
            * @description returns all rows which match the specified criteria, or null if none
            * @param colnames the column names to look for values in. Order must match vals array
            * @param vals the vals to search for in the colnames array. Order must match colnames array.
            */
            rowsByColsWithVals(rows: any[], colnames: string[], vals: string[]): any[];
            /**
                * @description returns a perfect, deep clone of a JSON serializable object -- suitable for cloning actScripts,
                * but not for anything with methods.
                * @param script
                */
            clone(script: any): any;
            toLines(text: string): string[];
            words(text: string): string[];
    }
    export default ActScripts;
}

declare module 'UAENGINE/Core/Engine/Utils/Collections' {
    class Collections {
        findArrElWithPropVal(array: any[], properties: string[], values: any[]): any;
        numElementsWithPropVal(array: any[], properties: string[], values: any[]): number;
        allElementsWithPropVal(array: any[], properties: string[], values: any[]): any[];
        getUniqValsFromArrays(rows: any, arrs: string[]): string[];
        /**
          * @description shuffle and return an array
          * @param a array to be shuffled
          */
        shuffle(a: any): any[];
    }
    export default Collections;
}

declare module 'UAENGINE/Core/Engine/Utils/Mixins' {
    class Mixins {
        static applyMixins(derivedCtor: any, baseCtors: any[]): void;
    }
    export default Mixins;
}

declare module 'UAENGINE/Core/Engine/Utils/Colors' {
    class Colors {
    }
    export default Colors;
}

declare module 'UAENGINE/Core/Engine/Utils/Text' {
    class Text {
            /**
                 * @description concatenate an array of strings, with a seperator substring. For no seperator, use ""
                 * @param array the array of strings to combine
                 * @param seperator the seperator substring to insert between entries, like underscore. For no seperator, use ""
                 */
            concat(array: string[], seperator: string): string;
            getUniq(vals: string[]): string[];
            /**
                * @description break a string into a string array, based on the provided seperator substring, and remove falsy values
                * @param text the string to break into a string array
                * @param seperator the seperator substring
                */
            unstringifyArray(txt: string, seperator: string): string[];
            propertiesFromString(rawText: string, lineSeperator: string, valueAssigner: string, valueSeperator: string): object;
            split(text: string, seperator: string): string[];
    }
    export default Text;
}

declare module 'UAENGINE/Core/Engine/Utils/Vectors' {
    import Point from "UAENGINE/Core/Geom/Point";
    class Vectors {
        protected _pointFactory: Point;
        getPointGrid(hor: number[], vert: number[]): Array<Point>;
    }
    export default Vectors;
}

